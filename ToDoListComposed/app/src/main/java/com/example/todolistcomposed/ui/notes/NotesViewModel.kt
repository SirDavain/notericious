package com.example.todolistcomposed.ui.notes

import android.util.Log
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.todolistcomposed.Task
import com.example.todolistcomposed.TaskRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.SharingStarted
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.map
import kotlinx.coroutines.flow.stateIn
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class NotesViewModel @Inject constructor(
    private val taskRepository: TaskRepository,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    private val noteId: Int? = savedStateHandle.get<Int>("noteId") // Or String if it's a String ID

    // Holds the full note object, useful if you need other fields
    private val _currentNote = MutableStateFlow<Task?>(null)

    // Specific StateFlow for the title to be observed by the UI
    // It's initialized when the note is loaded
    val noteTitle: StateFlow<String> = _currentNote
        .map { it?.title ?: "Loading..." } // Default or loading state
        .stateIn(viewModelScope,
            SharingStarted.WhileSubscribed(5000), "Loading...")

    // If you only want to manage the title string directly as editable state
    // var editableTitle by mutableStateOf("")
    //    private set

    init {
        if (noteId != null && noteId != 0 && noteId != -1) { // Check for valid ID (0 or -1 might be new note flags)
            loadNote(noteId)
        } else {
            // Handle new note creation case - e.g., initialize with a default new note
            // For simplicity, this example focuses on existing notes.
            // You might initialize _currentNote with a default Task object here for a new note.
            // And noteTitle would reflect "New Note" or similar.
            viewModelScope.launch {
                _currentNote.value = Task(
                    title = "New Note Title",
                    completedOrReopenedTimestamp = System.currentTimeMillis(),
                    isNote = true
                )
                // editableTitle = _currentNote.value?.title ?: "New Note Title"
            }
        }
    }

    private fun loadNote(id: Int) {
        viewModelScope.launch {
            // If getTaskById is suspend:
            _currentNote.value = taskRepository.getTaskById(id)
            // editableTitle = _currentNote.value?.title ?: "Note not found"

            // If getTaskById returns a Flow:
            /*taskRepository.getTaskById(id).distinctUntilChanged().collect { task ->
                _currentNote.value = task
                // editableTitle = task?.title ?: "Note not found"
            }*/
        }
    }

    fun updateNoteTitle(newTitle: String) {
        val noteToUpdate = _currentNote.value
        if (noteToUpdate != null && noteToUpdate.title != newTitle) {
            val updatedNote = noteToUpdate.copy(title = newTitle)
            viewModelScope.launch {
                taskRepository.update(updatedNote)
                _currentNote.value = updatedNote // Update local state immediately
                // editableTitle = newTitle // Update if using separate editableTitle state
                Log.d("NotesViewModel", "Note title updated and saved: $newTitle")
            }
        } else if (noteToUpdate == null && noteId == null /* or your new note flag */) {
            // Handle saving a new note for the first time
            val newNote = Task(
                title = newTitle,
                completedOrReopenedTimestamp = System.currentTimeMillis(),
                isNote = true
                // id will be auto-generated by Room
            )
            viewModelScope.launch {
                taskRepository.insert(newNote) // Assuming insert gives back the ID or you re-fetch
                // You might want to navigate to the saved note's ID or update the current noteId
                Log.d("NotesViewModel", "New note saved with title: $newTitle")
                // Potentially load the newly inserted note to get its ID for _currentNote
            }
        }
    }

    // Add methods to update note content as well
    fun updateNoteContent(newContent: String) {
        val noteToUpdate = _currentNote.value
        if (noteToUpdate != null && noteToUpdate.content != newContent) {
            val updatedNote = noteToUpdate.copy(content = newContent)
            viewModelScope.launch {
                taskRepository.update(updatedNote)
                _currentNote.value = updatedNote
            }
        }
    }

}